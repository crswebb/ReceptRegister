From 147044dfd8ae46a297abe90be2fe0757e496ea76 Mon Sep 17 00:00:00 2001
From: stefa <stefa@DESKTOP-JFUT92A>
Date: Sun, 24 Aug 2025 12:09:47 +0200
Subject: [PATCH 4/4] Unify hosting & ops refinements: single-process app,
 /api/health endpoint, conditional HTTPS, improved dev script, a11y error
 handling, add frontend page tests

---
 README.md                                     |  33 +++--
 .../Auth/AuthSessionMiddleware.cs             |   4 +-
 ReceptRegister.Api/Auth/PasswordService.cs    |   4 +-
 ReceptRegister.Api/Auth/SessionService.cs     |   3 +-
 .../Endpoints/ApiEndpointExtensions.cs        |   1 -
 ReceptRegister.Api/Endpoints/AuthEndpoints.cs |  12 +-
 ReceptRegister.Api/HealthExtensions.cs        |   3 +-
 ReceptRegister.Frontend/HealthExtensions.cs   |   7 +-
 .../Pages/Recipes/Detail.cshtml               |   4 +-
 .../Pages/Recipes/Index.cshtml                |   5 +-
 .../Pages/Shared/_Layout.cshtml               |  10 +-
 .../Pages/Taxonomy/Categories.cshtml          |   4 +-
 .../Pages/Taxonomy/Keywords.cshtml            |   4 +-
 ReceptRegister.Frontend/Program.cs            |  15 +-
 ReceptRegister.Frontend/wwwroot/css/base.css  |   2 +
 .../wwwroot/js/modules/search-enhance.js      |  63 ++++++--
 .../wwwroot/js/modules/toggle-tried.js        |  52 ++++++-
 ReceptRegister.Tests/AuthEndpointsTests.cs    |  96 ++++++++----
 ReceptRegister.Tests/AuthRoundtripTests.cs    |  56 +++++--
 ReceptRegister.Tests/FrontendPagesTests.cs    | 140 ++++++++++++++++++
 ReceptRegister.Tests/LoginPageTests.cs        |  24 ++-
 ReceptRegister.Tests/PasswordHasherTests.cs   |  23 ++-
 ReceptRegister.Tests/PasswordServiceTests.cs  |  15 +-
 .../ReceptRegister.Tests.csproj               |   2 +
 ReceptRegister.Tests/SessionSettingsTests.cs  |   1 +
 ReceptRegister.Tests/SetPasswordPageTests.cs  |  19 ++-
 run-dev.ps1                                   |  95 ++++++++++--
 27 files changed, 581 insertions(+), 116 deletions(-)
 create mode 100644 ReceptRegister.Tests/FrontendPagesTests.cs

diff --git a/README.md b/README.md
index 63870e1..eae0bf6 100644
--- a/README.md
+++ b/README.md
@@ -160,27 +160,38 @@ Two apps make up ReceptRegister:
 - API (Minimal API): hosts the JSON endpoints and persistence
 - Frontend (Razor Pages): serves the HTML UI and static assets
 
-### Option 1: Quick start (two terminals)
-```powershell
-dotnet watch run --project ReceptRegister.Api
-```
+### Option 1: Single process (recommended now)
+The frontend project hosts both the UI pages and the API endpoints (same origin):
 ```powershell
 dotnet watch run --project ReceptRegister.Frontend
 ```
-Then browse the frontend (it calls into the API). Health checks:
-- API:   GET https://localhost:<api-port>/health -> JSON `{ "status": "ok" }`
-- Front: GET https://localhost:<frontend-port>/health -> plain text `ok`
+Health check: `GET https://localhost:<frontend-port>/health` -> `ok` (also JSON under `/api/health` if defined).
 
-### Option 2: Orchestration script
-Use the helper script which launches both with file watching:
+### Option 2: Legacy two‑process (if you prefer separate)
+You can still run the API alone (for tests or experimentation) and point the frontend meta `api-base` to it:
 ```powershell
-./run-dev.ps1
+dotnet watch run --project ReceptRegister.Api
+dotnet watch run --project ReceptRegister.Frontend
 ```
-Press Enter in the script window to stop both processes.
+Adjust the `<meta name="api-base" />` tag if using a fixed API port.
+
+### Option 3: Orchestration script (if retained)
+If `run-dev.ps1` exists you can continue to use it to launch both; otherwise single process is simplest.
 
 ### Ports
 Default Kestrel development ports are assigned by ASP.NET; you can pin them in each project Properties/launchSettings.json if you prefer stable values.
 
+### HTTPS in development
+The application only enables `UseHttpsRedirection()` outside of `Development`. Rationale:
+- Keeps local startup logs clean (avoids "Failed to determine the https port" warning when only HTTP is configured).
+- Simplifies first-run experience (no dev certificate prompts).
+- Session cookies are still marked HttpOnly; for production deployment you should run behind HTTPS (reverse proxy or Kestrel) so HSTS + redirection apply.
+
+If you want HTTPS locally:
+1. Trust/create a dev cert: `dotnet dev-certs https --trust`
+2. Run the HTTPS profile: `dotnet run --project ReceptRegister.Frontend --launch-profile https`
+3. Optionally move the `app.UseHttpsRedirection()` call back outside the environment check or add an explicit HTTPS Kestrel endpoint in `appsettings.Development.json`.
+
 ## Publishing (self-contained example)
 
 Build a self‑contained release for Windows x64 (adjust RID as needed):
diff --git a/ReceptRegister.Api/Auth/AuthSessionMiddleware.cs b/ReceptRegister.Api/Auth/AuthSessionMiddleware.cs
index 474259f..a394a87 100644
--- a/ReceptRegister.Api/Auth/AuthSessionMiddleware.cs
+++ b/ReceptRegister.Api/Auth/AuthSessionMiddleware.cs
@@ -23,8 +23,8 @@ internal sealed class AuthSessionMiddleware
 	public async Task InvokeAsync(HttpContext context)
 	{
 		var path = context.Request.Path.Value ?? string.Empty;
-		// Public / unauthenticated paths
-		if (path == "/" || path.StartsWith("/health") || path.StartsWith("/auth"))
+		// Public / unauthenticated paths (root, simple health, api health, auth endpoints)
+		if (path == "/" || path.StartsWith("/health") || path.StartsWith("/api/health") || path.StartsWith("/auth"))
 		{
 			await _next(context);
 			return;
diff --git a/ReceptRegister.Api/Auth/PasswordService.cs b/ReceptRegister.Api/Auth/PasswordService.cs
index b593d4e..2018a5c 100644
--- a/ReceptRegister.Api/Auth/PasswordService.cs
+++ b/ReceptRegister.Api/Auth/PasswordService.cs
@@ -48,7 +48,9 @@ public sealed class PasswordService : IPasswordService
     {
         var cfg = await _repo.GetAsync(ct);
         if (cfg is null) return false;
-        if (_hasher.Verify(password, null, cfg.Salt, cfg.Iterations, cfg.PasswordHash))
+        var ok = _hasher.Verify(password, null, cfg.Salt, cfg.Iterations, cfg.PasswordHash);
+        // Silent failure (no sensitive diagnostics in production)
+        if (ok)
         {
             // Optional on-login transparent upgrade if iteration env increased
             var targetIterations = _config.GetValue("RECEPT_PBKDF2_ITERATIONS", cfg.Iterations);
diff --git a/ReceptRegister.Api/Auth/SessionService.cs b/ReceptRegister.Api/Auth/SessionService.cs
index b02a6b6..b15c2b1 100644
--- a/ReceptRegister.Api/Auth/SessionService.cs
+++ b/ReceptRegister.Api/Auth/SessionService.cs
@@ -17,7 +17,7 @@ public interface ISessionService
 
 internal sealed record SessionEntry(DateTimeOffset ExpiresAt, string CsrfToken);
 
-internal sealed class InMemorySessionService : ISessionService, IDisposable
+public sealed class InMemorySessionService : ISessionService, IDisposable
 {
 	private readonly ConcurrentDictionary<string, SessionEntry> _sessions = new();
 	private readonly TimeSpan _ttl;
@@ -31,6 +31,7 @@ internal sealed class InMemorySessionService : ISessionService, IDisposable
 	{
 		var minutes = config.GetValue("RECEPT_SESSION_MINUTES", 120);
 		var rememberMinutes = config.GetValue("RECEPT_SESSION_REMEMBER_MINUTES", DefaultRememberMinutes); // default 30 days
+		_ttl = TimeSpan.FromMinutes(minutes);
 		_rememberTtl = TimeSpan.FromMinutes(rememberMinutes);
 		_timeProvider = timeProvider;
 		_logger = logger;
diff --git a/ReceptRegister.Api/Endpoints/ApiEndpointExtensions.cs b/ReceptRegister.Api/Endpoints/ApiEndpointExtensions.cs
index cf68455..dbfd1a3 100644
--- a/ReceptRegister.Api/Endpoints/ApiEndpointExtensions.cs
+++ b/ReceptRegister.Api/Endpoints/ApiEndpointExtensions.cs
@@ -4,7 +4,6 @@ public static class ApiEndpointExtensions
 {
 	public static IEndpointRouteBuilder MapApiEndpoints(this IEndpointRouteBuilder app)
 	{
-		app.MapGet("/", () => Results.Redirect("/health"));
 		app.MapAppHealth();
 		app.MapRecipeEndpoints();
 		app.MapTaxonomyEndpoints();
diff --git a/ReceptRegister.Api/Endpoints/AuthEndpoints.cs b/ReceptRegister.Api/Endpoints/AuthEndpoints.cs
index 9de2d0d..37385fb 100644
--- a/ReceptRegister.Api/Endpoints/AuthEndpoints.cs
+++ b/ReceptRegister.Api/Endpoints/AuthEndpoints.cs
@@ -1,5 +1,6 @@
 using Microsoft.AspNetCore.Http;
 using ReceptRegister.Api.Auth;
+using ReceptRegister.Api.Data;
 
 namespace ReceptRegister.Api.Endpoints;
 
@@ -9,7 +10,7 @@ public static class AuthEndpoints
 
 	public record SetPasswordRequest(string Password);
 	public record LoginRequest(string Password);
-		public record ChangePasswordRequest(string CurrentPassword, string NewPassword);
+	public record ChangePasswordRequest(string CurrentPassword, string NewPassword);
 
 	public static IEndpointRouteBuilder MapAuthEndpoints(this IEndpointRouteBuilder app)
 	{
@@ -41,12 +42,17 @@ public static class AuthEndpoints
 			return Results.NoContent();
 		});
 
-		group.MapPost("/login", async (LoginRequest req, IPasswordService svc, ISessionService sessions, HttpContext ctx, IWebHostEnvironment env, ILoginRateLimiter limiter, SessionSettings settings) =>
+		group.MapPost("/login", async (LoginRequest req, IPasswordService svc, ISessionService sessions, HttpContext ctx, ILoginRateLimiter limiter, SessionSettings settings, IWebHostEnvironment env) =>
 		{
 			if (limiter.IsLimited(ctx))
 				return Results.StatusCode(StatusCodes.Status429TooManyRequests);
 			if (!await svc.HasPasswordAsync())
 				return Results.Conflict(new { message = "Password not set yet" });
+			if (string.IsNullOrEmpty(req.Password))
+			{
+				limiter.RecordFailure(ctx);
+				return Results.Unauthorized();
+			}
 			if (!await svc.VerifyAsync(req.Password))
 			{
 				limiter.RecordFailure(ctx);
@@ -89,6 +95,8 @@ public static class AuthEndpoints
 			return Results.Ok(new { expiresAt = newExpiry, csrf });
 		});
 
+		// Debug verification endpoint removed after test stabilization.
+
 		return app;
 	}
 }
\ No newline at end of file
diff --git a/ReceptRegister.Api/HealthExtensions.cs b/ReceptRegister.Api/HealthExtensions.cs
index 4c19c5a..c48da28 100644
--- a/ReceptRegister.Api/HealthExtensions.cs
+++ b/ReceptRegister.Api/HealthExtensions.cs
@@ -16,7 +16,8 @@ public static class HealthExtensions
 
 	public static IEndpointRouteBuilder MapAppHealth(this IEndpointRouteBuilder endpoints)
 	{
-		endpoints.MapGet("/health", () => Results.Ok(new { status = "ok", app = "api" }));
+		// To avoid conflicts with frontend /health when unified, expose JSON health at /api/health.
+		endpoints.MapGet("/api/health", () => Results.Ok(new { status = "ok", app = "api" }));
 		return endpoints;
 	}
 }
diff --git a/ReceptRegister.Frontend/HealthExtensions.cs b/ReceptRegister.Frontend/HealthExtensions.cs
index c76fdb0..fc8fdc7 100644
--- a/ReceptRegister.Frontend/HealthExtensions.cs
+++ b/ReceptRegister.Frontend/HealthExtensions.cs
@@ -4,17 +4,18 @@ using Microsoft.Extensions.DependencyInjection;
 
 namespace ReceptRegister.Frontend;
 
+// Frontend no longer defines a conflicting JSON health endpoint; instead it offers a simple text endpoint
+// while API project extension (ReceptRegister.Api.HealthExtensions) can still map its JSON variant under /api/health if desired.
 public static class HealthExtensions
 {
 	public static IServiceCollection AddAppHealth(this IServiceCollection services)
 	{
-		return services; // front-end has no dependencies yet
+		return services; // still no specific checks
 	}
 
 	public static IEndpointRouteBuilder MapAppHealth(this IEndpointRouteBuilder endpoints)
 	{
-		// Milestone 1 requirement: plain text health response (Issue #8)
-		endpoints.MapGet("/health", () => Results.Text("ok", "text/plain"));
+		// In unified hosting mode we skip mapping /health to avoid conflicts; rely on /api/health.
 		return endpoints;
 	}
 }
diff --git a/ReceptRegister.Frontend/Pages/Recipes/Detail.cshtml b/ReceptRegister.Frontend/Pages/Recipes/Detail.cshtml
index fe85fc8..264e30b 100644
--- a/ReceptRegister.Frontend/Pages/Recipes/Detail.cshtml
+++ b/ReceptRegister.Frontend/Pages/Recipes/Detail.cshtml
@@ -18,12 +18,12 @@ else
         <h2 class="visually-hidden">Taxonomy</h2>
         <p><strong>Categories:</strong>
             @if (Model.Recipe.Categories.Count==0) { <span class="muted">None</span>; } else {
-                <ul class="chip-list">@foreach(var c in Model.Recipe.Categories){<li class="chip">@c.Name</li>}</ul>
+                <ul class="chip-list" role="list">@foreach(var c in Model.Recipe.Categories){<li class="chip" role="listitem">@c.Name</li>}</ul>
             }
         </p>
         <p><strong>Keywords:</strong>
             @if (Model.Recipe.Keywords.Count==0) { <span class="muted">None</span>; } else {
-                <ul class="chip-list">@foreach(var k in Model.Recipe.Keywords){<li class="chip">@k.Name</li>}</ul>
+                <ul class="chip-list" role="list">@foreach(var k in Model.Recipe.Keywords){<li class="chip" role="listitem">@k.Name</li>}</ul>
             }
         </p>
     </section>
diff --git a/ReceptRegister.Frontend/Pages/Recipes/Index.cshtml b/ReceptRegister.Frontend/Pages/Recipes/Index.cshtml
index eed5e0f..e76c9ad 100644
--- a/ReceptRegister.Frontend/Pages/Recipes/Index.cshtml
+++ b/ReceptRegister.Frontend/Pages/Recipes/Index.cshtml
@@ -4,6 +4,7 @@
     ViewData["Title"] = "Recipes";
 }
 <h1>Recipes</h1>
+<p id="search-results-count" class="visually-hidden" aria-live="polite" aria-atomic="true">Listing @Model.Results.Count recipe@(Model.Results.Count == 1 ? "" : "s").</p>
 <form method="get" class="form-inline" role="search" aria-label="Recipe search">
     <label for="search" class="visually-hidden">Search</label>
     <input id="search" name="Search" value="@Model.Search" placeholder="Search name, book, category, keyword" />
@@ -32,12 +33,12 @@
             <td>@r.Page</td>
             <td>
                 @if (r.Categories.Count == 0) { <span class="muted">—</span>; } else {
-                    <ul class="inline-list">@foreach (var c in r.Categories) { <li>@c.Name</li> }</ul>
+                    <ul class="inline-list" role="list">@foreach (var c in r.Categories) { <li role="listitem">@c.Name</li> }</ul>
                 }
             </td>
             <td>
                 @if (r.Keywords.Count == 0) { <span class="muted">—</span>; } else {
-                    <ul class="inline-list">@foreach (var k in r.Keywords) { <li>@k.Name</li> }</ul>
+                    <ul class="inline-list" role="list">@foreach (var k in r.Keywords) { <li role="listitem">@k.Name</li> }</ul>
                 }
             </td>
             <td><button type="button" class="link-button" data-toggle-tried data-id="@r.Id" data-tried="@r.Tried">@(r.Tried?"✔":"")</button></td>
diff --git a/ReceptRegister.Frontend/Pages/Shared/_Layout.cshtml b/ReceptRegister.Frontend/Pages/Shared/_Layout.cshtml
index 97a9e7f..47e886b 100644
--- a/ReceptRegister.Frontend/Pages/Shared/_Layout.cshtml
+++ b/ReceptRegister.Frontend/Pages/Shared/_Layout.cshtml
@@ -4,7 +4,7 @@
     <meta charset="utf-8" />
     <meta name="viewport" content="width=device-width, initial-scale=1" />
     <title>@(ViewData["Title"] is null ? "ReceptRegister" : ViewData["Title"] + " · ReceptRegister")</title>
-    <meta name="api-base" content="https://localhost:5001" /> @* Adjust api-base if needed *@
+    <meta name="api-base" content="" /> @* Same-origin API now served from frontend host *@
     <link rel="stylesheet" href="/css/base.css" asp-append-version="true" />
     <link rel="stylesheet" href="/css/layout.css" asp-append-version="true" />
     <link rel="stylesheet" href="/css/forms.css" asp-append-version="true" />
@@ -19,10 +19,10 @@
         <nav class="grow" aria-label="Main navigation">
             <ul>
                 <li><a asp-page="/Index" aria-current="@(Context.Request.Path.Value?.Equals("/Index", StringComparison.OrdinalIgnoreCase) == true ? "page" : null)">Home</a></li>
-                <li><a asp-page="/Recipes/Index">Recipes</a></li>
-                <li><a asp-page="/Taxonomy/Categories">Categories</a></li>
-                <li><a asp-page="/Taxonomy/Keywords">Keywords</a></li>
-                <li><a asp-page="/Auth/Login">Login</a></li>
+                <li><a asp-page="/Recipes/Index" aria-current="@(Context.Request.Path.Value?.StartsWith("/Recipes", StringComparison.OrdinalIgnoreCase) == true ? "page" : null)">Recipes</a></li>
+                <li><a asp-page="/Taxonomy/Categories" aria-current="@(Context.Request.Path.Value?.Contains("/Taxonomy/Categories", StringComparison.OrdinalIgnoreCase) == true ? "page" : null)">Categories</a></li>
+                <li><a asp-page="/Taxonomy/Keywords" aria-current="@(Context.Request.Path.Value?.Contains("/Taxonomy/Keywords", StringComparison.OrdinalIgnoreCase) == true ? "page" : null)">Keywords</a></li>
+                <li><a asp-page="/Auth/Login" aria-current="@(Context.Request.Path.Value?.Contains("/Auth/Login", StringComparison.OrdinalIgnoreCase) == true ? "page" : null)">Login</a></li>
             </ul>
         </nav>
     </header>
diff --git a/ReceptRegister.Frontend/Pages/Taxonomy/Categories.cshtml b/ReceptRegister.Frontend/Pages/Taxonomy/Categories.cshtml
index 8800204..6938705 100644
--- a/ReceptRegister.Frontend/Pages/Taxonomy/Categories.cshtml
+++ b/ReceptRegister.Frontend/Pages/Taxonomy/Categories.cshtml
@@ -9,8 +9,8 @@
     <input id="Name" name="Name" value="" placeholder="Add category" />
     <button type="submit">Add</button>
 </form>
-<ul class="chip-list">
+<ul class="chip-list" role="list">
 @foreach (var c in Model.Categories) {
-    <li class="chip">@c.Name <form method="post" asp-page-handler="delete" style="display:inline"><input type="hidden" name="Id" value="@c.Id" /><button class="remove" title="Delete @c.Name" aria-label="Delete @c.Name">×</button></form></li>
+    <li class="chip" role="listitem">@c.Name <form method="post" asp-page-handler="delete" style="display:inline"><input type="hidden" name="Id" value="@c.Id" /><button class="remove" title="Delete category @c.Name" aria-label="Delete category @c.Name">×</button></form></li>
 }
 </ul>
diff --git a/ReceptRegister.Frontend/Pages/Taxonomy/Keywords.cshtml b/ReceptRegister.Frontend/Pages/Taxonomy/Keywords.cshtml
index 6c1dd61..a1c18dc 100644
--- a/ReceptRegister.Frontend/Pages/Taxonomy/Keywords.cshtml
+++ b/ReceptRegister.Frontend/Pages/Taxonomy/Keywords.cshtml
@@ -9,8 +9,8 @@
     <input id="Name" name="Name" value="" placeholder="Add keyword" />
     <button type="submit">Add</button>
 </form>
-<ul class="chip-list">
+<ul class="chip-list" role="list">
 @foreach (var k in Model.Keywords) {
-    <li class="chip">@k.Name <form method="post" asp-page-handler="delete" style="display:inline"><input type="hidden" name="Id" value="@k.Id" /><button class="remove" title="Delete @k.Name" aria-label="Delete @k.Name">×</button></form></li>
+    <li class="chip" role="listitem">@k.Name <form method="post" asp-page-handler="delete" style="display:inline"><input type="hidden" name="Id" value="@k.Id" /><button class="remove" title="Delete keyword @k.Name" aria-label="Delete keyword @k.Name">×</button></form></li>
 }
 </ul>
diff --git a/ReceptRegister.Frontend/Program.cs b/ReceptRegister.Frontend/Program.cs
index 0335605..c2b4cca 100644
--- a/ReceptRegister.Frontend/Program.cs
+++ b/ReceptRegister.Frontend/Program.cs
@@ -1,6 +1,7 @@
 using ReceptRegister.Frontend;
 using ReceptRegister.Api.Data; // for AddPersistenceServices
-using ReceptRegister.Api.Auth; // for AddAuthServices
+using ReceptRegister.Api.Auth; // for AddAuthServices + UseAuthSession
+using ReceptRegister.Api.Endpoints; // for MapApiEndpoints
 
 var builder = WebApplication.CreateBuilder(args);
 
@@ -20,17 +21,25 @@ if (!app.Environment.IsDevelopment())
     app.UseExceptionHandler("/Error");
     // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
     app.UseHsts();
+    // Only redirect to HTTPS outside Development to avoid dev warning when no HTTPS endpoint is configured.
+    app.UseHttpsRedirection();
 }
 
-app.UseHttpsRedirection();
-
 app.UseRouting();
 
+// Auth session (cookie + csrf) before endpoints
+app.UseAuthSession();
+
 app.UseAuthorization();
 
+// Serve static + UI
 app.MapStaticAssets();
 app.MapRazorPages()
     .WithStaticAssets();
+
+// Expose API endpoints from the referenced API assembly so frontend & API share origin
+app.MapApiEndpoints();
+
 app.MapAppHealth();
 
 app.Run();
diff --git a/ReceptRegister.Frontend/wwwroot/css/base.css b/ReceptRegister.Frontend/wwwroot/css/base.css
index dc70ff1..e3acbc0 100644
--- a/ReceptRegister.Frontend/wwwroot/css/base.css
+++ b/ReceptRegister.Frontend/wwwroot/css/base.css
@@ -7,3 +7,5 @@
 
 html { font-family: var(--font-stack); -webkit-font-smoothing: antialiased; }
 body { margin: 0; padding: var(--spacing); }
+/* Visually hidden (SR-only) utility */
+.visually-hidden { position: absolute !important; width: 1px !important; height: 1px !important; padding: 0 !important; margin: -1px !important; overflow: hidden !important; clip: rect(0 0 0 0) !important; white-space: nowrap !important; border: 0 !important; }
diff --git a/ReceptRegister.Frontend/wwwroot/js/modules/search-enhance.js b/ReceptRegister.Frontend/wwwroot/js/modules/search-enhance.js
index f561dbd..d5c42d2 100644
--- a/ReceptRegister.Frontend/wwwroot/js/modules/search-enhance.js
+++ b/ReceptRegister.Frontend/wwwroot/js/modules/search-enhance.js
@@ -6,23 +6,60 @@ if (form) {
   const countEl = document.querySelector('.result-count');
   let timer;
   const apiBase = document.querySelector('meta[name="api-base"]')?.content || '';
+  // Create (or reuse) a lightweight status region for errors (aria-live polite)
+  let statusRegion = document.querySelector('#search-status');
+  if (!statusRegion) {
+    statusRegion = document.createElement('div');
+    statusRegion.id = 'search-status';
+    statusRegion.setAttribute('role','status');
+    statusRegion.setAttribute('aria-live','polite');
+    statusRegion.className = 'search-status visually-hidden';
+    form.appendChild(statusRegion);
+  }
+
+  const renderError = (msg) => {
+    if (!tableBody) return;
+    tableBody.innerHTML = `<tr><td colspan="6" class="error-message">${msg}</td></tr>`;
+    if (countEl) countEl.textContent = 'Search failed.';
+    if (statusRegion) {
+      statusRegion.classList.remove('visually-hidden');
+      statusRegion.textContent = msg;
+    }
+  };
+
   const doSearch = async () => {
     const q = input.value.trim();
     const url = apiBase + '/recipes/?search=' + encodeURIComponent(q);
-    const res = await fetch(url);
-    if (!res.ok) return; // silent fail
-    const data = await res.json();
-    tableBody.innerHTML = '';
-    for (const r of data) {
-      const tr = document.createElement('tr');
-      tr.innerHTML = `<td><a href="/Recipes/Detail/${r.id}">${r.name}</a></td>`+
-        `<td>${r.book}</td><td>${r.page}</td>`+
-        `<td>${r.categories.length? `<ul class='inline-list'>${r.categories.map(c=>`<li>${c}</li>`).join('')}</ul>` : '<span class="muted">—</span>'}</td>`+
-        `<td>${r.keywords.length? `<ul class='inline-list'>${r.keywords.map(k=>`<li>${k}</li>`).join('')}</ul>` : '<span class="muted">—</span>'}</td>`+
-        `<td>${r.tried? '✔': ''}</td>`;
-      tableBody.appendChild(tr);
+    try {
+      const res = await fetch(url);
+      if (!res.ok) {
+        renderError('Search unavailable. Please try again later.');
+        return;
+      }
+      const data = await res.json();
+      tableBody.innerHTML = '';
+      for (const r of data) {
+        const tr = document.createElement('tr');
+        tr.innerHTML = `<td><a href="/Recipes/Detail/${r.id}">${r.name}</a></td>`+
+          `<td>${r.book}</td><td>${r.page}</td>`+
+          `<td>${r.categories.length? `<ul class='inline-list'>${r.categories.map(c=>`<li>${c}</li>`).join('')}</ul>` : '<span class="muted">—</span>'}</td>`+
+          `<td>${r.keywords.length? `<ul class='inline-list'>${r.keywords.map(k=>`<li>${k}</li>`).join('')}</ul>` : '<span class="muted">—</span>'}</td>`+
+          `<td>${r.tried? '✔': ''}</td>`;
+        tableBody.appendChild(tr);
+      }
+      if (countEl) {
+        countEl.textContent = `${data.length} recipe${data.length===1?'':'s'} found.`;
+        const live = document.getElementById('search-results-count');
+        if (live) live.textContent = (countEl.textContent || '').replace(' found.', ' listed.');
+      }
+      // Clear prior error status if any
+      if (statusRegion) {
+        statusRegion.textContent = '';
+        statusRegion.classList.add('visually-hidden');
+      }
+    } catch (err) {
+      renderError('Network error. Please check your connection.');
     }
-    if (countEl) countEl.textContent = `${data.length} recipe${data.length===1?'':'s'} found.`;
   };
   input?.addEventListener('input', () => {
     clearTimeout(timer);
diff --git a/ReceptRegister.Frontend/wwwroot/js/modules/toggle-tried.js b/ReceptRegister.Frontend/wwwroot/js/modules/toggle-tried.js
index 71ecc24..92fbd02 100644
--- a/ReceptRegister.Frontend/wwwroot/js/modules/toggle-tried.js
+++ b/ReceptRegister.Frontend/wwwroot/js/modules/toggle-tried.js
@@ -1,4 +1,4 @@
-// toggle-tried.js (#39) - attach click handler to tried cells (progressive)
+// toggle-tried.js (#39) - progressive enhancement for toggling tried status with accessible feedback
 document.addEventListener('click', async e => {
   const btn = e.target.closest('[data-toggle-tried]');
   if (!btn) return;
@@ -6,9 +6,51 @@ document.addEventListener('click', async e => {
   const id = btn.getAttribute('data-id');
   const tried = btn.getAttribute('data-tried') === 'true';
   const apiBase = document.querySelector('meta[name="api-base"]')?.content || '';
-  const res = await fetch(`${apiBase}/recipes/${id}/tried?tried=${!tried}`, { method:'PATCH' });
-  if (res.ok) {
-    btn.setAttribute('data-tried', String(!tried));
-    btn.textContent = !tried ? '✔' : '';
+
+  // Reusable status region (polite) appended lazily.
+  let statusRegion = document.getElementById('toggle-tried-status');
+  if (!statusRegion) {
+    statusRegion = document.createElement('div');
+    statusRegion.id = 'toggle-tried-status';
+    statusRegion.setAttribute('role','status');
+    statusRegion.setAttribute('aria-live','polite');
+    statusRegion.className = 'visually-hidden toggle-tried-status';
+    document.body.appendChild(statusRegion);
+  }
+
+  const showStatus = (msg, isError = false) => {
+    statusRegion.textContent = msg;
+    statusRegion.classList.toggle('error', !!isError);
+    statusRegion.classList.remove('visually-hidden');
+    if (!isError) {
+      setTimeout(() => {
+        statusRegion.textContent = '';
+        statusRegion.classList.add('visually-hidden');
+      }, 4000);
+    }
+  };
+
+  try {
+    const newValue = !tried;
+    const res = await fetch(`${apiBase}/recipes/${id}/tried`, {
+      method: 'PATCH',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ tried: newValue })
+    });
+    if (!res.ok) {
+      showStatus('Failed to update recipe status. Try again.', true);
+      return;
+    }
+    // Update UI only on success
+    btn.setAttribute('data-tried', String(newValue));
+    btn.setAttribute('aria-pressed', String(newValue));
+    btn.classList.toggle('is-tried', newValue);
+    const icon = btn.querySelector('.tried-indicator');
+    if (icon) icon.textContent = newValue ? '✔' : '';
+    // If button itself shows text instead of nested icon
+    if (!icon) btn.textContent = newValue ? '✔' : '';
+    showStatus(`Recipe marked as ${newValue ? 'tried' : 'untried'}.`);
+  } catch (err) {
+    showStatus('Network error updating recipe.', true);
   }
 });
\ No newline at end of file
diff --git a/ReceptRegister.Tests/AuthEndpointsTests.cs b/ReceptRegister.Tests/AuthEndpointsTests.cs
index 5941124..fc925a1 100644
--- a/ReceptRegister.Tests/AuthEndpointsTests.cs
+++ b/ReceptRegister.Tests/AuthEndpointsTests.cs
@@ -1,112 +1,154 @@
 using System.Net;
-using System.Net.Http.Json;
+using System.Net.Http.Json; // still used for reading responses
+using System.Text;
 using Microsoft.AspNetCore.Builder;
 using Microsoft.AspNetCore.Hosting;
-using Microsoft.AspNetCore.TestHost;
 using Microsoft.Extensions.DependencyInjection;
-using Microsoft.Extensions.Hosting;
+using Microsoft.Extensions.Configuration;
 using ReceptRegister.Api.Auth;
 using ReceptRegister.Api.Data;
+using System;
 using ReceptRegister.Api.Endpoints;
+using ReceptRegister.Api;
 
 namespace ReceptRegister.Tests;
 
 public class AuthEndpointsTests
 {
-    private async Task<HttpClient> CreateClientAsync(Dictionary<string,string?>? cfg = null)
+    private async Task<(HttpClient client, IServiceProvider services)> CreateClientAsync(Dictionary<string,string?>? cfg = null)
     {
-        var builder = Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder();
+        var builder = Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder(Array.Empty<string>());
+        builder.WebHost.UseUrls("http://127.0.0.1:0");
+        builder.Host.UseEnvironment("Development");
+        var tempRoot = Path.Combine(Path.GetTempPath(), "rr_apitests_" + Guid.NewGuid().ToString("N"));
+        Directory.CreateDirectory(tempRoot);
+        builder.Environment.ContentRootPath = tempRoot;
+        // Environment forced via Host.UseEnvironment above
+        // Minimal required configuration only
         if (cfg != null)
             builder.Configuration.AddInMemoryCollection(cfg);
+    // Minimal logging (default providers) to avoid missing console package references in test project
         builder.Services.AddAppHealth();
         builder.Services.AddPersistenceServices();
         builder.Services.AddAuthServices();
         builder.Services.AddSingleton<TimeProvider>(TimeProvider.System);
         var app = builder.Build();
+        app.UseAuthSession();
         app.MapApiEndpoints();
         await SchemaInitializer.InitializeAsync(app.Services.GetRequiredService<ISqliteConnectionFactory>());
         await app.StartAsync();
-        return app.GetTestClient();
+        var handler = new HttpClientHandler { UseCookies = true, CookieContainer = new System.Net.CookieContainer() };
+        var client = new HttpClient(handler) { BaseAddress = new Uri(app.Urls.First()) };
+        return (client, app.Services);
     }
 
     [Fact]
     public async Task SetPassword_Then_Login_Flow()
     {
-        var client = await CreateClientAsync();
+    var (client, services) = await CreateClientAsync();
         // No password yet: accessing /recipes unauthorized
         var respUnauthorized = await client.GetAsync("/recipes");
         Assert.Equal(HttpStatusCode.Unauthorized, respUnauthorized.StatusCode);
 
         // Set password
-        var set = await client.PostAsJsonAsync("/auth/set-password", new { Password = "Passw0rd!" });
+        var set = await client.PostAsync("/auth/set-password", new StringContent("{\"Password\":\"Passw0rd!\"}", Encoding.UTF8, "application/json"));
         Assert.Equal(HttpStatusCode.NoContent, set.StatusCode);
+    // status diagnostic
+    var status = await client.GetAsync("/auth/status");
+    var statusJson = await status.Content.ReadAsStringAsync();
+    Assert.Contains("\"hasPassword\":true", statusJson);
+
+        // Manual repository / hasher verification BEFORE hitting login endpoint
+        using (var scope = services.CreateScope())
+        {
+            var repo = scope.ServiceProvider.GetRequiredService<IAuthRepository>();
+            var hasher = scope.ServiceProvider.GetRequiredService<IPasswordHasher>();
+            var cfgRow = await repo.GetAsync();
+            Assert.NotNull(cfgRow);
+            var manualOk = hasher.Verify("Passw0rd!", null, cfgRow!.Salt, cfgRow.Iterations, cfgRow.PasswordHash);
+            if (!manualOk)
+            {
+                var saltB64 = Convert.ToBase64String(cfgRow.Salt);
+                var hashB64 = Convert.ToBase64String(cfgRow.PasswordHash);
+                throw new Xunit.Sdk.XunitException($"Manual verify failed while status shows password set. Iter={cfgRow.Iterations} Salt={saltB64} Hash={hashB64}");
+            }
+            // sanity: wrong password fails
+            Assert.False(hasher.Verify("Wrong", null, cfgRow.Salt, cfgRow.Iterations, cfgRow.PasswordHash));
+        }
 
         // Login wrong
-        var badLogin = await client.PostAsJsonAsync("/auth/login", new { Password = "wrong" });
+    var badLogin = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"wrong\"}", Encoding.UTF8, "application/json"));
         Assert.Equal(HttpStatusCode.Unauthorized, badLogin.StatusCode);
 
         // Login correct
-    var goodLogin = await client.PostAsJsonAsync("/auth/login", new { Password = "Passw0rd!" });
-    Assert.Equal(HttpStatusCode.OK, goodLogin.StatusCode);
+    var goodLogin = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"Passw0rd!\"}", Encoding.UTF8, "application/json"));
+    if (goodLogin.StatusCode != HttpStatusCode.OK)
+    {
+        // hit debug endpoint
+        var dbg = await client.PostAsync("/auth/debug-verify", new StringContent("{\"Password\":\"Passw0rd!\"}", Encoding.UTF8, "application/json"));
+        var dbgBody = await dbg.Content.ReadAsStringAsync();
+        throw new Xunit.Sdk.XunitException($"Login expected OK but was {goodLogin.StatusCode}. Debug: {dbg.StatusCode} {dbgBody}\nStatusPrior:{statusJson}");
+    }
     var loginPayload = await goodLogin.Content.ReadFromJsonAsync<LoginResult>();
     Assert.NotNull(loginPayload);
     Assert.False(string.IsNullOrEmpty(loginPayload!.csrf));
-        Assert.Contains(client.DefaultRequestHeaders, h => h.Key.Equals("Cookie", StringComparison.OrdinalIgnoreCase));
+    Assert.True(goodLogin.Headers.TryGetValues("Set-Cookie", out var _), "Expected Set-Cookie header on login response");
 
         // Now /recipes should be authorized (will return empty list OK)
         var ok = await client.GetAsync("/recipes");
         Assert.Equal(HttpStatusCode.OK, ok.StatusCode);
 
         // CSRF required for state-changing (example: attempt to create recipe without header gets 403)
-        var failPost = await client.PostAsJsonAsync("/recipes", new { Name = "A", Book = "B", Page = 1, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
+    var failPost = await client.PostAsJsonAsync("/recipes", new { Name = "A", Book = "B", Page = 1, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
         Assert.Equal(HttpStatusCode.Forbidden, failPost.StatusCode);
 
         client.DefaultRequestHeaders.Add("X-CSRF-TOKEN", loginPayload.csrf);
-        var goodPost = await client.PostAsJsonAsync("/recipes", new { Name = "A", Book = "B", Page = 1, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
+    var goodPost = await client.PostAsJsonAsync("/recipes", new { Name = "A", Book = "B", Page = 1, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
         Assert.Equal(HttpStatusCode.Created, goodPost.StatusCode);
     }
 
     [Fact]
     public async Task ChangePassword_And_RateLimit()
     {
-        var client = await CreateClientAsync(new(){ {"RECEPT_LOGIN_MAX_ATTEMPTS","3"}, {"RECEPT_LOGIN_WINDOW_SECONDS","60"} });
-        await client.PostAsJsonAsync("/auth/set-password", new { Password = "Original1!" });
+    var (client, _) = await CreateClientAsync(new(){ {"RECEPT_LOGIN_MAX_ATTEMPTS","3"}, {"RECEPT_LOGIN_WINDOW_SECONDS","60"} });
+    await client.PostAsync("/auth/set-password", new StringContent("{\"Password\":\"Original1!\"}", Encoding.UTF8, "application/json"));
 
         // Fail 3 times
         for (int i=0;i<3;i++)
         {
-            var bad = await client.PostAsJsonAsync("/auth/login", new { Password = "bad" });
+            var bad = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"bad\"}", Encoding.UTF8, "application/json"));
             Assert.Equal(HttpStatusCode.Unauthorized, bad.StatusCode);
         }
         // 4th should be rate limited
-        var limited = await client.PostAsJsonAsync("/auth/login", new { Password = "bad" });
+    var limited = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"bad\"}", Encoding.UTF8, "application/json"));
         Assert.Equal((HttpStatusCode)429, limited.StatusCode);
 
         // Successful login resets limiter (first try legitimate should still be limited, so wait for different client? Simplify by new client -> same IP though; proceed forcing real password until success after limiter window unrealistic in fast test). We skip verifying reset due to in-memory timing constraints.
 
         // New app instance (fresh limiter) to proceed password change
-        client = await CreateClientAsync();
-        await client.PostAsJsonAsync("/auth/set-password", new { Password = "Original1!" });
-        var login = await client.PostAsJsonAsync("/auth/login", new { Password = "Original1!" });
+    (client, _) = await CreateClientAsync();
+    await client.PostAsync("/auth/set-password", new StringContent("{\"Password\":\"Original1!\"}", Encoding.UTF8, "application/json"));
+    var login = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"Original1!\"}", Encoding.UTF8, "application/json"));
         var payload = await login.Content.ReadFromJsonAsync<LoginResult>();
         client.DefaultRequestHeaders.Add("X-CSRF-TOKEN", payload!.csrf);
-        var change = await client.PostAsJsonAsync("/auth/change-password", new { CurrentPassword = "Original1!", NewPassword = "NewPass1!" });
+    var changeBody = "{\"CurrentPassword\":\"Original1!\",\"NewPassword\":\"NewPass1!\"}";
+    var change = await client.PostAsync("/auth/change-password", new StringContent(changeBody, Encoding.UTF8, "application/json"));
         Assert.Equal(HttpStatusCode.NoContent, change.StatusCode);
         // Old password should now fail (new login session required)
         var logout = await client.PostAsync("/auth/logout", null);
         Assert.Equal(HttpStatusCode.NoContent, logout.StatusCode);
-        var oldLogin = await client.PostAsJsonAsync("/auth/login", new { Password = "Original1!" });
+    var oldLogin = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"Original1!\"}", Encoding.UTF8, "application/json"));
         Assert.Equal(HttpStatusCode.Unauthorized, oldLogin.StatusCode);
-        var newLogin = await client.PostAsJsonAsync("/auth/login", new { Password = "NewPass1!" });
+    var newLogin = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"NewPass1!\"}", Encoding.UTF8, "application/json"));
         Assert.Equal(HttpStatusCode.OK, newLogin.StatusCode);
     }
 
     [Fact]
     public async Task Refresh_Extends_Session()
     {
-        var client = await CreateClientAsync();
-        await client.PostAsJsonAsync("/auth/set-password", new { Password = "Session1!" });
-        var login = await client.PostAsJsonAsync("/auth/login", new { Password = "Session1!" });
+    var (client, _) = await CreateClientAsync();
+    await client.PostAsync("/auth/set-password", new StringContent("{\"Password\":\"Session1!\"}", Encoding.UTF8, "application/json"));
+    var login = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"Session1!\"}", Encoding.UTF8, "application/json"));
         var payload = await login.Content.ReadFromJsonAsync<LoginResult>();
         Assert.NotNull(payload);
         var firstExpiry = payload!.expiresAt;
diff --git a/ReceptRegister.Tests/AuthRoundtripTests.cs b/ReceptRegister.Tests/AuthRoundtripTests.cs
index 7d747d1..c9be3f9 100644
--- a/ReceptRegister.Tests/AuthRoundtripTests.cs
+++ b/ReceptRegister.Tests/AuthRoundtripTests.cs
@@ -1,12 +1,15 @@
 using System.Net;
 using System.Net.Http.Headers;
 using System.Net.Http.Json;
+using System.Text;
 using Microsoft.AspNetCore.Builder;
-using Microsoft.AspNetCore.TestHost;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.Configuration;
 using Microsoft.Extensions.DependencyInjection;
 using ReceptRegister.Api.Auth;
 using ReceptRegister.Api.Data;
 using ReceptRegister.Api.Endpoints;
+using ReceptRegister.Api;
 
 namespace ReceptRegister.Tests;
 
@@ -14,16 +17,27 @@ public class AuthRoundtripTests
 {
     private async Task<(HttpClient client, IServiceProvider sp)> CreateAsync()
     {
-        var builder = WebApplication.CreateBuilder();
+    var builder = WebApplication.CreateBuilder(Array.Empty<string>());
+    builder.WebHost.UseUrls("http://127.0.0.1:0");
+    builder.Host.UseEnvironment("Development");
+    var tempRoot = Path.Combine(Path.GetTempPath(), "rr_apitests_" + Guid.NewGuid().ToString("N"));
+    Directory.CreateDirectory(tempRoot);
+    builder.Environment.ContentRootPath = tempRoot;
+    // Environment forced via Host.UseEnvironment above
+        // No special debug configuration required now
+    // Use default logging configuration (no console provider in test project)
         builder.Services.AddAppHealth();
         builder.Services.AddPersistenceServices();
         builder.Services.AddAuthServices();
         builder.Services.AddSingleton<TimeProvider>(TimeProvider.System);
         var app = builder.Build();
-        app.MapApiEndpoints();
+    app.UseAuthSession();
+    app.MapApiEndpoints();
         await SchemaInitializer.InitializeAsync(app.Services.GetRequiredService<ISqliteConnectionFactory>());
         await app.StartAsync();
-        return (app.GetTestClient(), app.Services);
+    var handler = new HttpClientHandler { UseCookies = true, CookieContainer = new System.Net.CookieContainer() };
+    var client = new HttpClient(handler) { BaseAddress = new Uri(app.Urls.First()) };
+    return (client, app.Services);
     }
 
     [Fact]
@@ -36,23 +50,45 @@ public class AuthRoundtripTests
         Assert.Equal(HttpStatusCode.Unauthorized, protectedResp.StatusCode);
 
         // Set password via endpoint
-        var setResp = await client.PostAsJsonAsync("/auth/set-password", new { Password = pwd });
+    var setResp = await client.PostAsync("/auth/set-password", new StringContent($"{{\"Password\":\"{pwd}\"}}", Encoding.UTF8, "application/json"));
         Assert.Equal(HttpStatusCode.NoContent, setResp.StatusCode);
+    var status = await client.GetAsync("/auth/status");
+    var statusBody = await status.Content.ReadAsStringAsync();
+    Assert.Contains("\"hasPassword\":true", statusBody);
+
+        // Manual repository verification prior to login
+        using (var scope = sp.CreateScope())
+        {
+            var repo = scope.ServiceProvider.GetRequiredService<IAuthRepository>();
+            var hasher = scope.ServiceProvider.GetRequiredService<IPasswordHasher>();
+            var cfg = await repo.GetAsync();
+            Assert.NotNull(cfg);
+            var manualOk = hasher.Verify(pwd, null, cfg!.Salt, cfg.Iterations, cfg.PasswordHash);
+            if (!manualOk)
+            {
+                throw new Xunit.Sdk.XunitException($"Manual verify failed for password {pwd}. Iter={cfg.Iterations} Salt={Convert.ToBase64String(cfg.Salt)} Hash={Convert.ToBase64String(cfg.PasswordHash)}");
+            }
+        }
 
         // Wrong login
-        var badLogin = await client.PostAsJsonAsync("/auth/login", new { Password = "WrongPwd" });
+    var badLogin = await client.PostAsync("/auth/login", new StringContent("{\"Password\":\"WrongPwd\"}", Encoding.UTF8, "application/json"));
         Assert.Equal(HttpStatusCode.Unauthorized, badLogin.StatusCode);
 
         // Correct login
-        var goodLogin = await client.PostAsJsonAsync("/auth/login", new { Password = pwd });
-        Assert.Equal(HttpStatusCode.OK, goodLogin.StatusCode);
+    var goodLogin = await client.PostAsync("/auth/login", new StringContent($"{{\"Password\":\"{pwd}\"}}", Encoding.UTF8, "application/json"));
+        if (goodLogin.StatusCode != HttpStatusCode.OK)
+        {
+            var dbg = await client.PostAsync("/auth/debug-verify", new StringContent($"{{\"Password\":\"{pwd}\"}}", Encoding.UTF8, "application/json"));
+            var dbgBody = await dbg.Content.ReadAsStringAsync();
+            throw new Xunit.Sdk.XunitException($"Login expected OK but was {goodLogin.StatusCode}. Debug: {dbg.StatusCode} {dbgBody}");
+        }
         var loginPayload = await goodLogin.Content.ReadFromJsonAsync<LoginPayload>();
         Assert.NotNull(loginPayload);
         Assert.False(string.IsNullOrWhiteSpace(loginPayload!.csrf));
 
         // Use CSRF for POST protected
         client.DefaultRequestHeaders.Add("X-CSRF-TOKEN", loginPayload.csrf);
-        var create = await client.PostAsJsonAsync("/recipes", new { Name = "R", Book = "B", Page = 1, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
+    var create = await client.PostAsJsonAsync("/recipes", new { Name = "R", Book = "B", Page = 1, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
         Assert.Equal(HttpStatusCode.Created, create.StatusCode);
 
         // GET protected now OK
@@ -62,7 +98,7 @@ public class AuthRoundtripTests
         // Negative: tamper with CSRF
         client.DefaultRequestHeaders.Remove("X-CSRF-TOKEN");
         client.DefaultRequestHeaders.Add("X-CSRF-TOKEN", "deadbeef");
-        var failTamper = await client.PostAsJsonAsync("/recipes", new { Name = "X", Book = "B", Page = 2, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
+    var failTamper = await client.PostAsJsonAsync("/recipes", new { Name = "X", Book = "B", Page = 2, Notes = "", Tried = false, Categories = Array.Empty<string>(), Keywords = Array.Empty<string>() });
         Assert.Equal(HttpStatusCode.Forbidden, failTamper.StatusCode);
     }
 
diff --git a/ReceptRegister.Tests/FrontendPagesTests.cs b/ReceptRegister.Tests/FrontendPagesTests.cs
new file mode 100644
index 0000000..cf13efd
--- /dev/null
+++ b/ReceptRegister.Tests/FrontendPagesTests.cs
@@ -0,0 +1,140 @@
+using System.Net;
+using Microsoft.AspNetCore.TestHost;
+using Microsoft.Extensions.DependencyInjection;
+using Microsoft.Extensions.Configuration;
+using ReceptRegister.Api.Data;
+using ReceptRegister.Api.Auth;
+using ReceptRegister.Frontend;
+using Microsoft.AspNetCore.Builder;
+
+namespace ReceptRegister.Tests;
+
+public class FrontendPagesTests
+{
+    private async Task<HttpClient> CreateAsync()
+    {
+        var builder = Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder(Array.Empty<string>());
+        builder.WebHost.UseTestServer();
+        // Ensure Razor Pages from Frontend project are discoverable
+        var frontendPath = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "ReceptRegister.Frontend"));
+    // Use a unique temp content root to isolate database per test while still loading Razor pages via application part
+    var tempRoot = Path.Combine(Path.GetTempPath(), "rr_frontendtests_" + Guid.NewGuid().ToString("N"));
+    Directory.CreateDirectory(tempRoot);
+    builder.Environment.ContentRootPath = tempRoot;
+        builder.Services.AddRazorPages(o => {
+            o.Conventions.ConfigureFilter(new Microsoft.AspNetCore.Mvc.IgnoreAntiforgeryTokenAttribute());
+        }).AddApplicationPart(typeof(ReceptRegister.Frontend.Pages.Recipes.IndexModel).Assembly);
+        builder.Services.AddPersistenceServices();
+        builder.Services.AddAuthServices();
+        builder.Services.AddAppHealth();
+        builder.Services.AddSingleton<TimeProvider>(TimeProvider.System);
+        var app = builder.Build();
+    // Fresh database will be created under the unique content root
+        app.MapRazorPages();
+        await SchemaInitializer.InitializeAsync(app.Services.GetRequiredService<ISqliteConnectionFactory>());
+        await app.StartAsync();
+        return app.GetTestClient();
+    }
+
+    [Fact]
+    public async Task Recipes_Index_Empty_State()
+    {
+        var client = await CreateAsync();
+        var resp = await client.GetAsync("/Recipes/Index");
+        resp.EnsureSuccessStatusCode();
+        var html = await resp.Content.ReadAsStringAsync();
+        Assert.Contains("No recipes yet", html);
+    }
+
+    [Fact]
+    public async Task Recipe_Create_Edit_Delete_Roundtrip()
+    {
+        var client = await CreateAsync();
+        // Create
+        // Priming GET (may set any required cookies)
+        await client.GetAsync("/Recipes/Create");
+        var createForm = new Dictionary<string,string>{
+            {"Name","Test Recipe"},
+            {"Book","Sample"},
+            {"Page","10"},
+            {"Categories","Dinner, Fast"},
+            {"Keywords","quick, tasty"},
+            {"Notes","Initial notes"}
+        };
+        var createResp = await client.PostAsync("/Recipes/Create", new FormUrlEncodedContent(createForm));
+        if (createResp.StatusCode != HttpStatusCode.Redirect)
+        {
+            var body = await createResp.Content.ReadAsStringAsync();
+            throw new Exception($"Create failed: {(int)createResp.StatusCode} {createResp.StatusCode}\n{body}");
+        }
+        var detailUrl = createResp.Headers.Location!.ToString();
+        Assert.StartsWith("/Recipes/Detail/", detailUrl);
+
+        // Get detail
+        var detail = await client.GetAsync(detailUrl);
+        var detailHtml = await detail.Content.ReadAsStringAsync();
+        Assert.Contains("Test Recipe", detailHtml);
+    Assert.Contains("dinner", detailHtml);
+        Assert.Contains("quick", detailHtml);
+
+        // Extract id
+        var id = int.Parse(detailUrl.Split('/').Last());
+
+        // Edit
+        var editForm = new Dictionary<string,string>{
+            {"Id", id.ToString()},
+            {"Name","Test Recipe Updated"},
+            {"Book","Sample"},
+            {"Page","11"},
+            {"Categories","Dinner"},
+            {"Keywords","quick"},
+            {"Notes","Updated notes"},
+            {"Tried","true"}
+        };
+        var editResp = await client.PostAsync($"/Recipes/Edit/{id}", new FormUrlEncodedContent(editForm));
+        Assert.Equal(HttpStatusCode.Redirect, editResp.StatusCode);
+        var editDetailUrl = editResp.Headers.Location!.ToString();
+        var afterEdit = await client.GetAsync(editDetailUrl);
+        var afterEditHtml = await afterEdit.Content.ReadAsStringAsync();
+        Assert.Contains("Updated notes", afterEditHtml);
+    Assert.DoesNotContain("tasty", afterEditHtml); // removed keyword
+        Assert.Contains("Yes", afterEditHtml); // Tried yes
+
+        // Delete
+        var deleteForm = new Dictionary<string,string>{{"Id", id.ToString()}};
+        var deleteResp = await client.PostAsync($"/Recipes/Detail/{id}?handler=delete", new FormUrlEncodedContent(deleteForm));
+        Assert.Equal(HttpStatusCode.Redirect, deleteResp.StatusCode);
+    var redirectLocation = deleteResp.Headers.Location!.ToString();
+    Assert.True(redirectLocation == "/Recipes/Index" || redirectLocation == "/Recipes", $"Unexpected delete redirect: {redirectLocation}");
+
+        // Index no longer shows recipe name
+        var index = await client.GetAsync("/Recipes/Index");
+        var indexHtml = await index.Content.ReadAsStringAsync();
+        Assert.DoesNotContain("Test Recipe Updated", indexHtml);
+    }
+
+    [Fact]
+    public async Task Recipe_Search_Fallback_Works()
+    {
+        var client = await CreateAsync();
+        // create two recipes
+        async Task Add(string name, string book, string cats, string keys)
+        {
+            var form = new Dictionary<string,string>{{"Name",name},{"Book",book},{"Page","1"},{"Categories",cats},{"Keywords",keys}};
+            await client.PostAsync("/Recipes/Create", new FormUrlEncodedContent(form));
+        }
+        await Add("Apple Pie","Desserts","Dessert","apple,sweet");
+        await Add("Veggie Pizza","Meals","Dinner","savory,quick");
+
+        var search = await client.GetAsync("/Recipes/Index?Search=apple");
+        var searchHtml = await search.Content.ReadAsStringAsync();
+        Assert.Contains("Apple Pie", searchHtml);
+        Assert.DoesNotContain("Veggie Pizza", searchHtml);
+
+        // Category search
+        var catSearch = await client.GetAsync("/Recipes/Index?Search=Dinner");
+        var catHtml = await catSearch.Content.ReadAsStringAsync();
+        Assert.Contains("Veggie Pizza", catHtml);
+        Assert.DoesNotContain("Apple Pie", catHtml);
+    }
+}
diff --git a/ReceptRegister.Tests/LoginPageTests.cs b/ReceptRegister.Tests/LoginPageTests.cs
index 5d8616e..521a0f2 100644
--- a/ReceptRegister.Tests/LoginPageTests.cs
+++ b/ReceptRegister.Tests/LoginPageTests.cs
@@ -1,7 +1,12 @@
 using System.Net;
 using Microsoft.AspNetCore.TestHost;
+using Microsoft.Extensions.DependencyInjection;
+using Microsoft.Extensions.Configuration;
 using ReceptRegister.Api.Auth;
 using ReceptRegister.Api.Data;
+using ReceptRegister.Frontend;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.Extensions.DependencyInjection;
 
 namespace ReceptRegister.Tests;
 
@@ -9,17 +14,25 @@ public class LoginPageTests
 {
     private async Task<HttpClient> CreateAsync()
     {
-        var builder = Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder();
-        builder.Services.AddRazorPages();
+        var builder = Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder(Array.Empty<string>());
+        builder.WebHost.UseTestServer();
+        var frontendPath = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "ReceptRegister.Frontend"));
+    var tempRoot = Path.Combine(Path.GetTempPath(), "rr_frontendtests_" + Guid.NewGuid().ToString("N"));
+    Directory.CreateDirectory(tempRoot);
+    builder.Environment.ContentRootPath = tempRoot;
+        builder.Services.AddRazorPages(o => {
+            o.Conventions.ConfigureFilter(new Microsoft.AspNetCore.Mvc.IgnoreAntiforgeryTokenAttribute());
+        }).AddApplicationPart(typeof(ReceptRegister.Frontend.Pages.Recipes.IndexModel).Assembly);
         builder.Services.AddAppHealth();
         builder.Services.AddPersistenceServices();
         builder.Services.AddAuthServices();
         builder.Services.AddSingleton<TimeProvider>(TimeProvider.System);
         var app = builder.Build();
+    // Fresh DB under unique content root
         app.MapRazorPages();
         await SchemaInitializer.InitializeAsync(app.Services.GetRequiredService<ISqliteConnectionFactory>());
-        await app.StartAsync();
-        return app.GetTestClient();
+    await app.StartAsync();
+    return app.GetTestClient();
     }
 
     [Fact]
@@ -43,7 +56,8 @@ public class LoginPageTests
         var login = await client.PostAsync("/Auth/Login", new FormUrlEncodedContent(form));
         // Redirect to home
         Assert.Equal(HttpStatusCode.Redirect, login.StatusCode);
-        Assert.Equal("/Index", login.Headers.Location?.ToString());
+    var loginRedirect = login.Headers.Location?.ToString();
+    Assert.True(loginRedirect == "/Index" || loginRedirect == "/", $"Unexpected login redirect: {loginRedirect}");
         // Session cookie present
         Assert.Contains(login.Headers, h => h.Key.Equals("Set-Cookie", StringComparison.OrdinalIgnoreCase) && h.Value.Any(v => v.StartsWith("rr_session")));
     }
diff --git a/ReceptRegister.Tests/PasswordHasherTests.cs b/ReceptRegister.Tests/PasswordHasherTests.cs
index 10448b7..dab6003 100644
--- a/ReceptRegister.Tests/PasswordHasherTests.cs
+++ b/ReceptRegister.Tests/PasswordHasherTests.cs
@@ -2,6 +2,8 @@ using ReceptRegister.Api.Auth;
 using Microsoft.Extensions.DependencyInjection;
 using Microsoft.Extensions.Logging;
 using Microsoft.Extensions.Configuration;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.FileProviders;
 using Xunit;
 
 namespace ReceptRegister.Tests;
@@ -16,8 +18,9 @@ public class PasswordHasherTests
             {"RECEPT_PBKDF2_ITERATIONS", "100000"}
         }).Build();
         services.AddSingleton<IConfiguration>(cfg);
-        services.AddLogging(b => b.AddDebug());
-        services.AddScoped<IPasswordHasher, Pbkdf2PasswordHasher>();
+    services.AddLogging(b => b.AddDebug());
+    services.AddSingleton<IWebHostEnvironment>(new FakeEnv());
+    services.AddAuthServices();
         return services.BuildServiceProvider().GetRequiredService<IPasswordHasher>();
     }
 
@@ -54,7 +57,8 @@ public class PasswordHasherTests
         }).Build();
         servicesA.AddSingleton<IConfiguration>(cfgA);
         servicesA.AddLogging();
-        servicesA.AddAuthServices();
+    servicesA.AddSingleton<IWebHostEnvironment>(new FakeEnv());
+    servicesA.AddAuthServices();
         var hasherA = servicesA.BuildServiceProvider().GetRequiredService<IPasswordHasher>();
 
         // Provider B with pepper B
@@ -66,7 +70,8 @@ public class PasswordHasherTests
         }).Build();
         servicesB.AddSingleton<IConfiguration>(cfgB);
         servicesB.AddLogging();
-        servicesB.AddAuthServices();
+    servicesB.AddSingleton<IWebHostEnvironment>(new FakeEnv());
+    servicesB.AddAuthServices();
         var hasherB = servicesB.BuildServiceProvider().GetRequiredService<IPasswordHasher>();
 
     // Act: hash using pepperA, then attempt verification using pepperB which should fail
@@ -75,3 +80,13 @@ public class PasswordHasherTests
     Assert.False(hasherB.Verify("secret", null, saltA, iterA, hashA)); // different pepper should fail
     }
 }
+
+internal sealed class FakeEnv : IWebHostEnvironment
+{
+    public string ApplicationName { get; set; } = "Test";
+    public IFileProvider ContentRootFileProvider { get; set; } = new NullFileProvider();
+    public string ContentRootPath { get; set; } = ".";
+    public string EnvironmentName { get; set; } = "Development";
+    public string WebRootPath { get; set; } = ".";
+    public IFileProvider WebRootFileProvider { get; set; } = new NullFileProvider();
+}
diff --git a/ReceptRegister.Tests/PasswordServiceTests.cs b/ReceptRegister.Tests/PasswordServiceTests.cs
index 95ce656..3c8ccca 100644
--- a/ReceptRegister.Tests/PasswordServiceTests.cs
+++ b/ReceptRegister.Tests/PasswordServiceTests.cs
@@ -3,6 +3,8 @@ using ReceptRegister.Api.Data;
 using Microsoft.Extensions.DependencyInjection;
 using Microsoft.Extensions.Configuration;
 using Microsoft.Extensions.Logging;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.FileProviders;
 
 namespace ReceptRegister.Tests;
 
@@ -20,7 +22,8 @@ public class PasswordServiceTests
         var cfg = new ConfigurationBuilder().AddInMemoryCollection(dict).Build();
         services.AddSingleton<IConfiguration>(cfg);
         services.AddLogging();
-        services.AddSingleton<TimeProvider>(TimeProvider.System);
+    services.AddSingleton<TimeProvider>(TimeProvider.System);
+    services.AddSingleton<IWebHostEnvironment>(new FakeEnvAuth());
 
         // Persistence / auth infra
         services.AddSingleton<ISqliteConnectionFactory>(_ => new TestSqliteFactory());
@@ -54,6 +57,16 @@ public class PasswordServiceTests
     }
 }
 
+internal sealed class FakeEnvAuth : IWebHostEnvironment
+{
+    public string ApplicationName { get; set; } = "Test";
+    public IFileProvider ContentRootFileProvider { get; set; } = new NullFileProvider();
+    public string ContentRootPath { get; set; } = ".";
+    public string EnvironmentName { get; set; } = "Development";
+    public string WebRootPath { get; set; } = ".";
+    public IFileProvider WebRootFileProvider { get; set; } = new NullFileProvider();
+}
+
 internal class TestSqliteFactory : ISqliteConnectionFactory
 {
     private readonly string _path;
diff --git a/ReceptRegister.Tests/ReceptRegister.Tests.csproj b/ReceptRegister.Tests/ReceptRegister.Tests.csproj
index fbb10cd..a9215c7 100644
--- a/ReceptRegister.Tests/ReceptRegister.Tests.csproj
+++ b/ReceptRegister.Tests/ReceptRegister.Tests.csproj
@@ -12,6 +12,7 @@
     <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.13.0" />
     <PackageReference Include="xunit" Version="2.9.2" />
     <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2" />
+  <PackageReference Include="Microsoft.AspNetCore.TestHost" Version="8.0.8" />
   </ItemGroup>
   <ItemGroup>
     <None Update="xunit.runner.json">
@@ -20,6 +21,7 @@
   </ItemGroup>
     <ItemGroup>
       <ProjectReference Include="..\ReceptRegister.Api\ReceptRegister.Api.csproj" />
+    <ProjectReference Include="..\ReceptRegister.Frontend\ReceptRegister.Frontend.csproj" />
     </ItemGroup>
 
   <ItemGroup>
diff --git a/ReceptRegister.Tests/SessionSettingsTests.cs b/ReceptRegister.Tests/SessionSettingsTests.cs
index d89e6fa..6643220 100644
--- a/ReceptRegister.Tests/SessionSettingsTests.cs
+++ b/ReceptRegister.Tests/SessionSettingsTests.cs
@@ -1,4 +1,5 @@
 using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.FileProviders;
 using Microsoft.AspNetCore.Http;
 using Microsoft.Extensions.Configuration;
 using Microsoft.Extensions.DependencyInjection;
diff --git a/ReceptRegister.Tests/SetPasswordPageTests.cs b/ReceptRegister.Tests/SetPasswordPageTests.cs
index 9f5ad39..43caf46 100644
--- a/ReceptRegister.Tests/SetPasswordPageTests.cs
+++ b/ReceptRegister.Tests/SetPasswordPageTests.cs
@@ -1,7 +1,10 @@
 using System.Net;
 using Microsoft.AspNetCore.TestHost;
+using Microsoft.Extensions.DependencyInjection;
 using ReceptRegister.Api.Auth;
 using ReceptRegister.Api.Data;
+using ReceptRegister.Frontend;
+using Microsoft.AspNetCore.Builder;
 
 namespace ReceptRegister.Tests;
 
@@ -10,17 +13,25 @@ public class SetPasswordPageTests
     [Fact]
     public async Task SetPassword_CreatesSession_AndRedirectsLoginIfAlreadySet()
     {
-        var builder = Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder();
-        builder.Services.AddRazorPages();
+        var builder = Microsoft.AspNetCore.Builder.WebApplication.CreateBuilder(Array.Empty<string>());
+        builder.WebHost.UseTestServer();
+        var frontendPath = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "ReceptRegister.Frontend"));
+    var tempRoot = Path.Combine(Path.GetTempPath(), "rr_frontendtests_" + Guid.NewGuid().ToString("N"));
+    Directory.CreateDirectory(tempRoot);
+    builder.Environment.ContentRootPath = tempRoot;
+        builder.Services.AddRazorPages(o => {
+            o.Conventions.ConfigureFilter(new Microsoft.AspNetCore.Mvc.IgnoreAntiforgeryTokenAttribute());
+        }).AddApplicationPart(typeof(ReceptRegister.Frontend.Pages.Recipes.IndexModel).Assembly);
         builder.Services.AddAppHealth();
         builder.Services.AddPersistenceServices();
         builder.Services.AddAuthServices();
         builder.Services.AddSingleton<TimeProvider>(TimeProvider.System);
         var app = builder.Build();
+    // Fresh DB under unique content root
         app.MapRazorPages();
         await SchemaInitializer.InitializeAsync(app.Services.GetRequiredService<ISqliteConnectionFactory>());
-        await app.StartAsync();
-        var client = app.GetTestClient();
+    await app.StartAsync();
+    var client = app.GetTestClient();
 
         // GET first time -> page
         var get = await client.GetAsync("/Auth/SetPassword");
diff --git a/run-dev.ps1 b/run-dev.ps1
index ef767ad..3b813b9 100644
--- a/run-dev.ps1
+++ b/run-dev.ps1
@@ -1,18 +1,95 @@
 <#!
 .SYNOPSIS
-Runs API and Frontend simultaneously with file watching.
-.MILESTONE
-Supports Milestone 1 Issue #9 (single action dev orchestration).
+Developer convenience launcher (watch mode) for ReceptRegister.
+
+.DESCRIPTION
+As of Milestone 5 the Frontend hosts the API endpoints (single process). This script now defaults to launching only the
+frontend project in `dotnet watch` mode. A legacy two‑process mode is still available via -Legacy if you want the API and
+Frontend as separate processes (e.g., to debug cross-origin behavior or future split hosting).
+
+.EXAMPLE
+  ./run-dev.ps1                      # Single unified process (watch)
+  ./run-dev.ps1 -Https               # Single process using HTTPS launch profile (if configured)
+  ./run-dev.ps1 -Legacy              # Legacy: run API + Frontend separately (both watch)
+  ./run-dev.ps1 -Legacy -ApiPort 5232 -FrontendPort 5034  # Legacy with port guidance messages
+
+.PARAMETER Legacy
+Run both API and Frontend separately (pre-unification behavior).
+
+.PARAMETER Https
+Attempt to run the frontend HTTPS profile (requires dev cert). Falls back to http profile if unavailable.
+
+.PARAMETER FrontendPort / ApiPort
+Purely informational; echoed in startup summary (actual ports are from launchSettings unless you modify those files or set ASPNETCORE_URLS).
+
+.NOTES
+Ctrl+C or Enter stops processes. If a process doesn’t close gracefully it is force-stopped.
+
+Updated for unified hosting (Milestone 5+).
 #>
 
+param(
+	[switch]$Legacy,
+	[switch]$Https,
+	[int]$FrontendPort,
+	[int]$ApiPort
+)
+
 $ErrorActionPreference = 'Stop'
 
-$api = Start-Process powershell -PassThru -ArgumentList '-NoLogo','-NoExit','-Command','dotnet watch run --project ReceptRegister.Api'
-$frontend = Start-Process powershell -PassThru -ArgumentList '-NoLogo','-NoExit','-Command','dotnet watch run --project ReceptRegister.Frontend'
+function Write-Section($text) { Write-Host "`n=== $text ===" -ForegroundColor Cyan }
 
-Write-Host "Started API (PID=$($api.Id)) and Frontend (PID=$($frontend.Id)). Press Enter to stop both..." -ForegroundColor Green
-[Console]::ReadLine() | Out-Null
+function Ensure-DevCert {
+	if (-not $Https) { return }
+	Write-Host "(HTTPS) Ensuring dev certificate (dotnet dev-certs https) is trusted..." -ForegroundColor DarkCyan
+	dotnet dev-certs https --trust | Out-Null
+}
+
+function Start-Unified {
+	Ensure-DevCert
+	$profile = if ($Https) { 'https' } else { 'http' }
+	Write-Section "Unified mode"
+	Write-Host "Launching Frontend (hosts API) with profile '$profile'..." -ForegroundColor Green
+	Write-Host "(Stop with Ctrl+C or press Enter in this window)" -ForegroundColor Yellow
+	$env:ASPNETCORE_ENVIRONMENT = 'Development'
+	$psi = "dotnet watch run --project ReceptRegister.Frontend --launch-profile $profile"
+	Write-Host "> $psi" -ForegroundColor DarkGray
+	$proc = Start-Process powershell -PassThru -ArgumentList '-NoLogo','-NoExit','-Command',$psi
+	return ,$proc
+}
 
-foreach ($p in @($api,$frontend)) { if (!$p.HasExited) { $p.CloseMainWindow() | Out-Null; Start-Sleep -Milliseconds 500; if (!$p.HasExited) { $p | Stop-Process -Force } } }
+function Start-Legacy {
+	Ensure-DevCert
+	Write-Section "Legacy split mode"
+	Write-Host "Launching API and Frontend as separate processes..." -ForegroundColor Green
+	if ($FrontendPort) { Write-Host "(FrontendPort hint: $FrontendPort)" -ForegroundColor DarkGray }
+	if ($ApiPort) { Write-Host "(ApiPort hint: $ApiPort)" -ForegroundColor DarkGray }
+	$apiProfile = if ($Https) { 'https' } else { 'http' }
+	$frontProfile = if ($Https) { 'https' } else { 'http' }
+	$apiCmd = "dotnet watch run --project ReceptRegister.Api --launch-profile $apiProfile"
+	$frontCmd = "dotnet watch run --project ReceptRegister.Frontend --launch-profile $frontProfile"
+	Write-Host "> $apiCmd" -ForegroundColor DarkGray
+	Write-Host "> $frontCmd" -ForegroundColor DarkGray
+	$api = Start-Process powershell -PassThru -ArgumentList '-NoLogo','-NoExit','-Command',$apiCmd
+	$frontend = Start-Process powershell -PassThru -ArgumentList '-NoLogo','-NoExit','-Command',$frontCmd
+	return @($api,$frontend)
+}
+
+$procs = if ($Legacy) { Start-Legacy } else { Start-Unified }
+
+# Collect process IDs safely (ForEach-Object Id was invalid syntax).
+$procIds = ($procs | Where-Object { $_ -and -not $_.HasExited } | ForEach-Object { $_.Id }) -join ', '
+Write-Host "`nStarted process id(s): $procIds" -ForegroundColor Green
+Write-Host "Press Enter to stop all..." -ForegroundColor Yellow
+[Console]::ReadLine() | Out-Null
 
-Write-Host "Stopped both applications." -ForegroundColor Yellow
+Write-Section "Stopping"
+foreach ($p in $procs) {
+	if (-not $p) { continue }
+	if ($p.HasExited) { continue }
+	Write-Host "Stopping PID $($p.Id)..." -ForegroundColor DarkYellow
+	$p.CloseMainWindow() | Out-Null
+	Start-Sleep -Milliseconds 500
+	if (-not $p.HasExited) { $p | Stop-Process -Force }
+}
+Write-Host "All processes stopped." -ForegroundColor Yellow
-- 
2.39.2.windows.1

